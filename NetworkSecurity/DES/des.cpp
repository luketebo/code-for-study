#include <iostream>
using namespace std;

int jiami()
{

    // 明文
    int mingwen[64];

    cout << "请输入16位十六进制的明文:";
    string kk;
    cin >> kk;
    int len = kk.length();

    while (len != 16)
    {
        cout << "请重新输入16位十六进制的明文:";
        cin >> kk;
        len = kk.length();
    }

    int jishu = 0;
    for (int i = 0; i < 16; i++)
    {
        int a;
        if (kk[i] >= '0' && kk[i] <= '9')
            a = kk[i] - '0';
        else
            a = kk[i] - 'A' + 10;

        int n[4] = {0};
        int f = 0;
        while (a)
        {
            n[f] = a % 2;
            a = a / 2;
            f++;
        }
        mingwen[jishu * 4] = n[3];
        mingwen[jishu * 4 + 1] = n[2];
        mingwen[jishu * 4 + 2] = n[1];
        mingwen[jishu * 4 + 3] = n[0];
        jishu++;
    }

    //初始置换IP
    int IP[64] = {58, 50, 42, 34, 26, 18, 10, 2,
                  60, 52, 44, 36, 28, 20, 12, 4,
                  62, 54, 46, 38, 30, 22, 14, 6,
                  64, 56, 48, 40, 32, 24, 16, 8,
                  57, 49, 41, 33, 25, 17, 9, 1,
                  59, 51, 43, 35, 27, 19, 11, 3,
                  61, 53, 45, 37, 29, 21, 13, 5,
                  63, 55, 47, 39, 31, 23, 15, 7};

    // 选择运算E   32位明文扩充为48位
    int E[48] = {32, 1, 2, 3, 4, 5,
                 4, 5, 6, 7, 8, 9,
                 8, 9, 10, 11, 12, 13,
                 12, 13, 14, 15, 16, 17,
                 16, 17, 18, 19, 20, 21,
                 20, 21, 22, 23, 24, 25,
                 24, 25, 26, 27, 28, 29,
                 28, 29, 30, 31, 32, 1};

    // 64位秘钥     0123456789ABCDEF    56位的秘钥+8位校验码
    int miyao[64];
    cout << "请输入16位十六进制的秘钥:";
    string k_2;
    cin >> k_2;
    int len_2 = k_2.length();

    while (len_2 != 16)
    {
        cout << "请重新输入16位十六进制的秘钥:";
        cin >> k_2;
        len_2 = k_2.length();
    }

    int jishu_2 = 0;
    for (int i = 0; i < 16; i++)
    {
        int a;
        if (k_2[i] >= '0' && k_2[i] <= '9')
            a = k_2[i] - '0';
        else
            a = k_2[i] - 'A' + 10;

        int n[4] = {0};
        int f = 0;
        while (a)
        {
            n[f] = a % 2;
            a = a / 2;
            f++;
        }
        miyao[jishu_2 * 4] = n[3];
        miyao[jishu_2 * 4 + 1] = n[2];
        miyao[jishu_2 * 4 + 2] = n[1];
        miyao[jishu_2 * 4 + 3] = n[0];
        jishu_2++;
    }

    //置换选择1
    int IP_1[56] = {57, 49, 41, 33, 25, 17, 9,
                    1, 58, 50, 42, 34, 26, 18,
                    10, 2, 59, 51, 43, 35, 27,
                    19, 11, 3, 60, 52, 44, 36,
                    63, 55, 47, 39, 31, 23, 15,
                    7, 62, 54, 46, 38, 30, 22,
                    14, 6, 61, 53, 45, 37, 29,
                    21, 13, 5, 28, 20, 12, 4};

    // 16次左移对应的位数
    int weiyi[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
    // 置换选择2 秘钥56->48位压缩
    int IP_2[48] = {14, 17, 11, 24, 1, 5,
                    3, 28, 15, 6, 21, 10,
                    23, 19, 12, 4, 26, 8,
                    16, 7, 27, 20, 13, 2,
                    41, 52, 31, 37, 47, 55,
                    30, 40, 51, 45, 33, 48,
                    44, 49, 39, 56, 34, 53,
                    46, 42, 50, 36, 29, 32};

    // S盒

    int s[8][65] =
        {
            {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
             0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
             4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
             15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},
            {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
             3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
             0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
             13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 10, 5, 14, 9},
            {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
             13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
             13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
             1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},
            {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
             13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
             10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
             3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},
            {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
             14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
             4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
             11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},
            {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
             10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
             9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
             4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},
            {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
             13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
             1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
             6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},
            {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
             1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
             7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
             2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}};

    // P置换
    int P[32] = {16, 7, 20, 21, 29, 12, 28, 17,
                 1, 15, 23, 26, 5, 18, 31, 10,
                 2, 8, 24, 14, 32, 27, 3, 9,
                 19, 13, 30, 6, 22, 11, 4, 25};

    // 1初始置换
    // 1.1  64明文进行初始置换分左右
    int mingwen_1[64];
    int l[32], r[32];
    for (int i = 0; i < 64; i++)
    {
        mingwen_1[i] = mingwen[IP[i] - 1];
    }
    for (int i = 0; i < 32; i++)
    {
        l[i] = mingwen_1[i];
        r[i] = mingwen_1[i + 32];
    }
    cout << "明文初始置换M   =";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << " ";
        cout << mingwen_1[i];
    }
    cout << endl;

    // 1.2 56位秘钥初始置换分左右

    cout << "秘钥初始置换k0  =";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << " ";
        cout << miyao[i];
    }
    cout << endl;

    int ml[28], mr[28];
    int miyao_0[58];
    for (int i = 0; i < 58; i++)
    {
        miyao_0[i] = miyao[IP_1[i] - 1];
    }
    for (int i = 0; i < 28; i++)
    {
        ml[i] = miyao_0[i];
        mr[i] = miyao_0[i + 28];
    }

    // 2.循环加密
    for (int i = 0; i < 16; i++)
    {

        cout << "-------------------------------第" << i + 1 << "轮循环-----------------------------------" << endl;

        // 2.1明文左右交换
        int new_l[32], new_r[48];
        for (int j = 0; j < 32; j++)
        {
            new_l[j] = r[j];
        }

        // 2.2 右边32位拓展变换成48位
        for (int j = 0; j < 48; j++)
        {
            new_r[j] = r[E[j] - 1];
        }

        // 2.3 左右秘钥 左移
        int new_ml[28], new_mr[28];
        for (int j = 0; j < 28; j++)
        {
            new_ml[j] = ml[(j + 28 + weiyi[i]) % 28];
            new_mr[j] = mr[(j + 28 + weiyi[i]) % 28];
        }

        // 2.4  重新合并成56位的秘钥
        int miyao_1[56];
        for (int j = 0; j < 28; j++)
        {
            miyao_1[j] = new_ml[j];
            miyao_1[j + 28] = new_mr[j];
        }
        // 2.5  IP_2 56位秘钥压缩成48位的秘钥
        int k[48];
        for (int j = 0; j < 48; j++)
        {
            k[j] = miyao_1[IP_2[j] - 1];
        }

        cout << "k" << i + 1 << "             =";
        for (int j = 0; j < 48; j++)
        {
            if (j % 6 == 0)
                cout << " ";
            cout << k[j];
        }
        cout << endl;

        cout << "R" << i << "            "
             << "=";
        for (int j = 0; j < 48; j++)
        {
            if (j % 6 == 0)
                cout << " ";
            cout << new_r[j];
        }
        cout << endl;

        // 2.6   2.2和2.5XOR
        int new_r2[48];
        for (int j = 0; j < 48; j++)
        {
            new_r2[j] = new_r[j] ^ k[j];
        }

        cout << "R(i-1)^ki      "
             << "=";
        for (int j = 0; j < 48; j++)
        {
            if (j % 6 == 0)
                cout << " ";
            cout << new_r2[j];
        }
        cout << endl;

        // 2.7 s盒
        int new_r3[32];
        int b1, b2, b3, b4, b5, b6;
        int m = 0;
        for (int j = 0; j < 8; j++)
        {
            int row = ((new_r2[j * 6]) << 1) + (new_r2[j * 6 + 5]);                                                               //第1，6位组成行号
            int col = ((new_r2[j * 6 + 1]) << 3) + ((new_r2[j * 6 + 2]) << 2) + ((new_r2[j * 6 + 3]) << 1) + (new_r2[j * 6 + 4]); //第2，3，4，5位组成列号
                                                                                                                                  //找到s盒对应的数
            int a = s[j][16 * row + col];

            //转成对应的2进制
            int n[4] = {0};
            int f = 0;
            while (a)
            {
                n[f] = a % 2;
                a = a / 2;
                f++;
            }

            new_r3[m * 4] = n[3];
            new_r3[m * 4 + 1] = n[2];
            new_r3[m * 4 + 2] = n[1];
            new_r3[m * 4 + 3] = n[0];
            m++;
        }

        cout << "第" << i + 1 << "轮s盒"
             << "       =";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_r3[j];
        }
        cout << endl;

        // 2.8 P置换
        int new_r4[32];
        for (int j = 0; j < 32; j++)
        {
            new_r4[j] = new_r3[P[j] - 1];
        }

        cout << "P置换          "
             << "=";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_r4[j];
        }
        cout << endl;

        // 2.9 明文左边32位和2.8 new_r4[32] XOR
        int new_r5[32];
        for (int j = 0; j < 32; j++)
        {
            new_r5[j] = l[j] ^ new_r4[j];
            //更新左右明文，以便于下次循环
            l[j] = new_l[j];
            r[j] = new_r5[j];
        }

        cout << "R" << i + 1 << "             =";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_r5[j];
        }
        cout << endl;
        cout << "L" << i + 1 << "             =";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_l[j];
        }
        cout << endl;
        // 2.10 更新左右秘钥，以便于下次循环
        for (int j = 0; j < 28; j++)
        {
            ml[j] = new_ml[j];
            mr[j] = new_mr[j];
        }

        cout << "----------------------------------------------------------------------------" << endl
             << endl
             << endl;
    }

    // 3.  循环加密之后的明文mingwen_1[64]
    for (int i = 0; i < 32; i++)
    {
        mingwen_1[i] = r[i];
        mingwen_1[i + 32] = l[i];
    }

    //    cout<<"逆置换前=";
    //    for(int i=0;i<64;i++){
    //        cout<<mingwen_1[i];
    //    }
    //    cout<<endl<<endl;

    // 4.  逆置换
    int miwen[64];
    for (int i = 0; i < 64; i++)
    {
        miwen[IP[i] - 1] = mingwen_1[i];
    }

    // 5.输出

    cout << "原明文为：";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << endl;
        cout << mingwen[i];
    }
    cout << endl
         << endl;
    cout << "秘钥为：";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << endl;
        cout << miyao[i];
    }
    cout << endl
         << endl;
    cout << "密文为：";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << endl;
        cout << miwen[i];
    }
    //是否将密文转换成十六进制？（Y  or  N)

    cout << endl
         << endl
         << "是否将密文转换成十六进制？（Y  or  N)：";
    char YN;
    cin >> YN;
    cout << endl
         << "十六进制密文表示：";
    if (YN == 'Y')
    {
        for (int i = 0; i < 16; i++)
        {
            int q = miwen[i * 4] * 8 + miwen[i * 4 + 1] * 4 + miwen[i * 4 + 2] * 2 + miwen[i * 4 + 3];
            if (q >= 0 && q <= 9)
            {
                cout << q;
            }
            else
            {
                cout << hex << uppercase << q;
            }
        }
    }
    cout << endl
         << endl
         << "！！！！皆大欢喜，普天同庆！！！！" << endl;
    return 0;
}

int jiemi()
{
    // 密文
    int miwen[64];

    cout << "请输入16位十六进制的密文:";
    string kk;
    cin >> kk;
    int len = kk.length();

    while (len != 16)
    {
        cout << "请重新输入16位十六进制的密文:";
        cin >> kk;
        len = kk.length();
    }

    int jishu = 0;
    for (int i = 0; i < 16; i++)
    {
        int a;
        if (kk[i] >= '0' && kk[i] <= '9')
            a = kk[i] - '0';
        else
            a = kk[i] - 'A' + 10;

        int n[4] = {0};
        int f = 0;
        while (a)
        {
            n[f] = a % 2;
            a = a / 2;
            f++;
        }
        miwen[jishu * 4] = n[3];
        miwen[jishu * 4 + 1] = n[2];
        miwen[jishu * 4 + 2] = n[1];
        miwen[jishu * 4 + 3] = n[0];
        jishu++;
    }

    //初始置换IP
    int IP[64] = {58, 50, 42, 34, 26, 18, 10, 2,
                  60, 52, 44, 36, 28, 20, 12, 4,
                  62, 54, 46, 38, 30, 22, 14, 6,
                  64, 56, 48, 40, 32, 24, 16, 8,
                  57, 49, 41, 33, 25, 17, 9, 1,
                  59, 51, 43, 35, 27, 19, 11, 3,
                  61, 53, 45, 37, 29, 21, 13, 5,
                  63, 55, 47, 39, 31, 23, 15, 7};

    // 选择运算E   32位明文扩充为48位
    int E[48] = {32, 1, 2, 3, 4, 5,
                 4, 5, 6, 7, 8, 9,
                 8, 9, 10, 11, 12, 13,
                 12, 13, 14, 15, 16, 17,
                 16, 17, 18, 19, 20, 21,
                 20, 21, 22, 23, 24, 25,
                 24, 25, 26, 27, 28, 29,
                 28, 29, 30, 31, 32, 1};

    // 64位秘钥     0123456789ABCDEF    56位的秘钥+8位校验码
    int miyao[64];
    cout << "请输入16位十六进制的秘钥:";
    string k_2;
    cin >> k_2;
    int len_2 = k_2.length();

    while (len_2 != 16)
    {
        cout << "请重新输入16位十六进制的秘钥:";
        cin >> k_2;
        len_2 = k_2.length();
    }

    int jishu_2 = 0;
    for (int i = 0; i < 16; i++)
    {
        int a;
        if (k_2[i] >= '0' && k_2[i] <= '9')
            a = k_2[i] - '0';
        else
            a = k_2[i] - 'A' + 10;

        int n[4] = {0};
        int f = 0;
        while (a)
        {
            n[f] = a % 2;
            a = a / 2;
            f++;
        }
        miyao[jishu_2 * 4] = n[3];
        miyao[jishu_2 * 4 + 1] = n[2];
        miyao[jishu_2 * 4 + 2] = n[1];
        miyao[jishu_2 * 4 + 3] = n[0];
        jishu_2++;
    }

    //置换选择1
    int IP_1[56] = {57, 49, 41, 33, 25, 17, 9,
                    1, 58, 50, 42, 34, 26, 18,
                    10, 2, 59, 51, 43, 35, 27,
                    19, 11, 3, 60, 52, 44, 36,
                    63, 55, 47, 39, 31, 23, 15,
                    7, 62, 54, 46, 38, 30, 22,
                    14, 6, 61, 53, 45, 37, 29,
                    21, 13, 5, 28, 20, 12, 4};

    // 16次左移对应的位数
    int weiyi[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
    // 置换选择2 秘钥56->48位压缩
    int IP_2[48] = {14, 17, 11, 24, 1, 5,
                    3, 28, 15, 6, 21, 10,
                    23, 19, 12, 4, 26, 8,
                    16, 7, 27, 20, 13, 2,
                    41, 52, 31, 37, 47, 55,
                    30, 40, 51, 45, 33, 48,
                    44, 49, 39, 56, 34, 53,
                    46, 42, 50, 36, 29, 32};

    // S盒
    int s[8][65] =
        {
            {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
             0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
             4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
             15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},
            {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
             3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
             0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
             13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 10, 5, 14, 9},
            {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
             13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
             13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
             1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},
            {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
             13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
             10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
             3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},
            {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
             14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
             4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
             11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},
            {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
             10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
             9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
             4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},
            {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
             13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
             1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
             6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},
            {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
             1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
             7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
             2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}};

    // P置换
    int P[32] = {16, 7, 20, 21, 29, 12, 28, 17,
                 1, 15, 23, 26, 5, 18, 31, 10,
                 2, 8, 24, 14, 32, 27, 3, 9,
                 19, 13, 30, 6, 22, 11, 4, 25};

    // 1初始置换

    // 1.1  64密文进行逆置换分左右
    int miwen_1[64];
    int l[32], r[32];
    for (int i = 0; i < 64; i++)
    {
        miwen_1[i] = miwen[IP[i] - 1];
    }
    for (int i = 0; i < 32; i++)
    {
        r[i] = miwen_1[i];
        l[i] = miwen_1[i + 32];
    }
    cout << "密文逆置换     =";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << " ";
        cout << miwen_1[i];
    }
    cout << endl;

    // 1.2 56位秘钥初始置换分左右

    cout << "秘钥初始置换k0 =";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << " ";
        cout << miyao[i];
    }
    cout << endl;

    int ml_0[28], mr_0[28];
    int miyao_0[58];
    for (int i = 0; i < 58; i++)
    {
        miyao_0[i] = miyao[IP_1[i] - 1];
    }
    for (int i = 0; i < 28; i++)
    {
        ml_0[i] = miyao_0[i];
        mr_0[i] = miyao_0[i + 28];
    }

    // 因为加密过程一共左移了28位，回到了原来的位置，
    //所以我们要先将原始秘钥左移一次。

    int ml[28], mr[28];
    for (int j = 0; j < 28; j++)
    {
        ml[j] = ml_0[(j + 28 + 1) % 28];
        mr[j] = mr_0[(j + 28 + 1) % 28];
    }

    // 2.循环解密
    for (int i = 0; i < 16; i++)
    {

        cout << "-------------------------------第" << i + 1 << "轮循环解密-----------------------------------" << endl;

        // 2.1密文左右交换
        int new_l[32], new_r[48];
        for (int j = 0; j < 32; j++)
        {
            new_r[j] = l[j];
        }

        // 2.2 左边32位拓展变换成48位
        for (int j = 0; j < 48; j++)
        {
            new_l[j] = new_r[E[j] - 1];
        }

        // 2.3 左右秘钥 右移

        int new_ml[28], new_mr[28];
        for (int j = 0; j < 28; j++)
        {
            new_ml[j] = ml[(j + 28 - weiyi[16 - i]) % 28];
            new_mr[j] = mr[(j + 28 - weiyi[16 - i]) % 28];
        }

        // 2.4  重新合并成56位的秘钥
        int miyao_1[56];
        for (int j = 0; j < 28; j++)
        {
            miyao_1[j] = new_ml[j];
            miyao_1[j + 28] = new_mr[j];
        }
        // 2.5  IP_2 56位秘钥压缩成48位的秘钥
        int k[48];
        for (int j = 0; j < 48; j++)
        {
            k[j] = miyao_1[IP_2[j] - 1];
        }

        cout << "k" << 16 - i << "             =";
        for (int j = 0; j < 48; j++)
        {
            if (j % 6 == 0)
                cout << " ";
            cout << k[j];
        }
        cout << endl;

        cout << "L" << 16 - i << "             "
             << "=";
        for (int j = 0; j < 48; j++)
        {
            if (j % 6 == 0)
                cout << " ";
            cout << new_l[j];
        }
        cout << endl;

        // 2.6   2.2和2.5XOR
        int new_l2[48];
        for (int j = 0; j < 48; j++)
        {
            new_l2[j] = new_l[j] ^ k[j];
        }

        cout << "Li^ki         "
             << "=";
        for (int j = 0; j < 48; j++)
        {
            if (j % 6 == 0)
                cout << " ";
            cout << new_l2[j];
        }
        cout << endl;

        // 2.7 s盒
        int new_l3[32];
        int b1, b2, b3, b4, b5, b6;
        int m = 0;
        for (int j = 0; j < 8; j++)
        {
            int row = ((new_l2[j * 6]) << 1) + (new_l2[j * 6 + 5]);                                                               //第1，6位组成行号
            int col = ((new_l2[j * 6 + 1]) << 3) + ((new_l2[j * 6 + 2]) << 2) + ((new_l2[j * 6 + 3]) << 1) + (new_l2[j * 6 + 4]); //第2，3，4，5位组成列号
                                                                                                                                  //找到s盒对应的数
            int a = s[j][16 * row + col];

            //转成对应的2进制
            int n[4] = {0};
            int f = 0;
            while (a)
            {
                n[f] = a % 2;
                a = a / 2;
                f++;
            }

            new_l3[m * 4] = n[3];
            new_l3[m * 4 + 1] = n[2];
            new_l3[m * 4 + 2] = n[1];
            new_l3[m * 4 + 3] = n[0];
            m++;
        }

        cout << "第" << 16 - i << "轮s盒"
             << "       =";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_l3[j];
        }
        cout << endl;

        // 2.8 P置换
        int new_l4[32];
        for (int j = 0; j < 32; j++)
        {
            new_l4[j] = new_l3[P[j] - 1];
        }

        cout << "P置换          "
             << "=";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_l4[j];
        }
        cout << endl;

        // 2.9 密文右边32位和2.8 new_l4[32] XOR
        int new_l5[32];
        for (int j = 0; j < 32; j++)
        {
            new_l5[j] = r[j] ^ new_l4[j];
            //更新左右明文，以便于下次循环
            r[j] = new_r[j];
            l[j] = new_l5[j];
        }

        cout << "L" << 16 - i - 1 << "            =";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_l5[j];
        }
        cout << endl;
        cout << "R" << 16 - i - 1 << "            =";
        for (int j = 0; j < 32; j++)
        {
            if (j % 8 == 0)
                cout << " ";
            cout << new_r[j];
        }
        cout << endl;

        // 2.10 更新左右秘钥，以便于下次循环
        for (int j = 0; j < 28; j++)
        {
            ml[j] = new_ml[j];
            mr[j] = new_mr[j];
        }

        cout << "ml" << 16 - i << "=";
        for (int j = 0; j < 28; j++)
        {
            cout << ml[j];
        }
        cout << endl;
        cout << "mr" << 16 - i << "=";
        for (int j = 0; j < 28; j++)
        {
            cout << mr[j];
        }
        cout << endl;

        cout << "------------------------------------------------------------------------------" << endl
             << endl
             << endl;
    }

    // 3.  循环解密之后的密文miwen_1[64]
    for (int i = 0; i < 32; i++)
    {
        miwen_1[i] = l[i];
        miwen_1[i + 32] = r[i];
    }
    // 4.  初始置换
    int mingwen[64];
    for (int i = 0; i < 64; i++)
    {
        mingwen[IP[i] - 1] = miwen_1[i];
    }

    // 5.输出

    cout << "原密文为：";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << endl;
        cout << miwen[i];
    }
    cout << endl
         << endl;
    cout << "秘钥为：";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << endl;
        cout << miyao[i];
    }
    cout << endl
         << endl;
    cout << "明文为：";
    for (int i = 0; i < 64; i++)
    {
        if (i % 64 == 0)
            cout << endl;
        cout << mingwen[i];
    }
    //是否将明文转换成十六进制？（Y  or  N)

    cout << endl
         << endl
         << "是否将明文转换成十六进制？（Y  or  N)：";
    char YN;
    cin >> YN;
    cout << endl
         << "十六进制明表示：";
    if (YN == 'Y')
    {
        for (int i = 0; i < 16; i++)
        {
            int q = mingwen[i * 4] * 8 + mingwen[i * 4 + 1] * 4 + mingwen[i * 4 + 2] * 2 + mingwen[i * 4 + 3];
            if (q >= 0 && q <= 9)
            {
                cout << q;
            }
            else
            {
                cout << hex << uppercase << q;
            }
        }
    }
    cout << endl
         << endl
         << "！！！！皆大欢喜，普天同庆！！！！" << endl;
    return 0;
}

int main()
{

    while (1)
    {
        int number;
        cout << "===欢迎来到DES加密算法系统===" << endl;
        cout << "目前支持的操作有：" << endl;
        cout << "  1.加密操作；" << endl;
        cout << "  2.解密操作；" << endl;
        cout << "  0.退出。" << endl;
        cout << "=============================" << endl;
        cout << "请选择您项进行的操作：";
        cin >> number;
        cout << endl;

        if (number == 1)
        {
            jiami();
        }
        else if (number == 2)
        {
            jiemi();
        }
        else
        {
            cout << "您已成功退出系统，如果您对本次服务感到满意，欢迎五星好评^_^" << endl;
            return 0;
        }
    }
    return 0;
}