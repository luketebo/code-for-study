
                        Hello, data structure!

***************************************************************
* 1. 全排列      2. 归并排序             3. 最优二叉搜索树    *
* 4. 最大字段和  5. 最大公共子序列长度   6. 抢劫问题          *
* 7. 矩阵运算    8. 退出                                      *
* Please input the number of the data structure you want to use:

算法简介：
全排列
从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。
当m=n时所有的排列情况叫全排列。
公式：全排列数f(n)=n!(定义0!=1)
please input the string array:
abc
全排列算法
-----------排列后----------
将每一个元素与第一个元素交换
让之后的元素全排列
swap(a,a)
swap(b,b)
满足条件的排列：
a b c
swap(b,b)
swap(c,b)
满足条件的排列：
a c b
swap(b,c)
swap(a,a)
swap(b,a)
swap(a,a)
满足条件的排列：
b a c
swap(a,a)
swap(c,a)
满足条件的排列：
b c a
swap(a,c)
swap(a,b)
swap(c,a)
swap(b,b)
满足条件的排列：
c b a
swap(b,b)
swap(a,b)
满足条件的排列：
c a b
swap(b,a)
swap(a,c)
算法简介
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下 一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。
input the array's length: 4
input the array: 2 3 1 4
归并排序
分割点: 1
合并操作
2 3

分割点: 3
合并操作
1 4

分割点: 2
合并操作
1 2 3 4

1 2 3 4
*************************************
*              菜单                 *
*          1.矩阵相加               *
*          2.矩阵相减               *
*          3.矩阵相乘               *
*          4.矩阵数乘               *
*          5.矩阵求逆               *
*          6.退出                   *
*************************************
请输入您的选择：1
请输入矩阵1
输入行数与列数：
3 4
输入你的矩阵：
1 2 3 4
1 2 3 4
1 2 3 4
请输入矩阵2
输入行数与列数：
3 4
输入你的矩阵：
2 1 2 1
1 2 1 2
2 2 1 1
第一个矩阵为：
1  2  3  4
1  2  3  4
1  2  3  4
第二个矩阵为：
2  1  2  1
1  2  1  2
2  2  1  1
矩阵相加运算解法如下:
第一个矩阵与第二个矩阵对应的元素值依次相加
两个矩阵的第1行对应的元素相加的结果分别为
        3       3       5       5
两个矩阵的第2行对应的元素相加的结果分别为
        2       4       4       6
两个矩阵的第3行对应的元素相加的结果分别为
        3       4       4       5

结果为：
3  3  5  5
2  4  4  6
3  4  4  5
请输入您的选择：2
请输入矩阵1
输入行数与列数：
2 3
输入你的矩阵：
2 3 1
3 2 1
请输入矩阵2
输入行数与列数：
2 3
输入你的矩阵：
1 2 1
1 1 1
第一个矩阵为：
2  3  1
3  2  1
第二个矩阵为：
1  2  1
1  1  1
矩阵相减运算解法如下:
第一个矩阵与第二个矩阵对应的元素值依次相减
两个矩阵的第1行对应的元素相减的结果分别为
        1       1       0
两个矩阵的第2行对应的元素相减的结果分别为
        2       1       0

结果为：
1  1  0
2  1  0
请输入您的选择：3
请输入矩阵1
输入行数与列数：
2 3
输入你的矩阵：
2 1 2
2 3 1
请输入矩阵2
输入行数与列数：
3 2
输入你的矩阵：
1 2
2 3
3 1
第一个矩阵为：
2  1  2
2  3  1
第二个矩阵为：
1  2
2  3
3  1
矩阵相乘运算解法如下:
第一个矩阵的第1行乘第二个矩阵的每一列对应的元素，然后求和后按行排列为：
        10      9
第一个矩阵的第2行乘第二个矩阵的每一列对应的元素，然后求和后按行排列为：
        11      14
结果为：
10  9
11  14
请输入矩阵
输入行数与列数：
2 3
输入你的矩阵：
2 3 1
3 2 1
请输入数值
3
矩阵为：
2  3  1
3  2  1
数值为：
3
数乘运算解法如下:
矩阵的每个值依次乘这个数值
数据3与第1行的数相乘结果分别为
        6       9       3
数据3与第2行的数相乘结果分别为
        9       6       3
结果为：
6  9  3
9  6  3
请输入矩阵的行数: 2
请依次输入第1行的元素: 1 2
请依次输入第2行的元素: 3 2
原始矩阵:
   1         2
   3         2
1、求矩阵的逆首先我们要做的是求矩阵的行列式
顺序求和, 主对角线元素相乘之和依次是：
        2
主对角线元素相乘之和是2
逆序相减, 减去次对角线元素乘积依次是：
        6
主对角线元素相乘之和是6
因此，矩阵的行列式为：2-6=-4
去除元素A(0,0)得到的新矩阵为：
   2
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
去除元素A(0,1)得到的新矩阵为：
   3
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
去除元素A(1,0)得到的新矩阵为：
   2
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
去除元素A(1,1)得到的新矩阵为：
   1
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
矩阵的逆矩阵为:
-0.5       0.5
0.75     -0.25
输入节点数(小于99): 5
请输入节点的概率：
0.15 0.1 0.05 0.1 0.2
请输入空隙节点的概率：
0.05 0.1 0.05 0.05 0.05 0.1
开始计算最优二叉树...
初始化 w 和 e 数组:
w:
0       0       0       0       0       0
0.05    0       0       0       0       0
0       0.1     0       0       0       0
0       0       0.05    0       0       0
0       0       0       0.05    0       0
0       0       0       0       0.1     0

e:
0       0       0       0       0       0
0.05    0       0       0       0       0
0       0.1     0       0       0       0
0       0       0.05    0       0       0
0       0       0       0.05    0       0
0       0       0       0       0.1     0
开始填表:
w[1][1]: 0.4
e[1][1]: 0.65

w[2][2]: 0.25
e[2][2]: 0.4

w[3][3]: 0.2
e[3][3]: 0.35

w[4][4]: 0.2
e[4][4]: 0.3

w[5][5]: 0.35
e[5][5]: 0.5

w[1][2]: 0.6
e[1][2]: 1.2

w[2][3]: 0.35
e[2][3]: 0.75

w[3][4]: 0.35
e[3][4]: 0.75

w[4][5]: 0.5
e[4][5]: 0.9

w[1][3]: 0.7
e[1][3]: 1.65

w[2][4]: 0.5
e[2][4]: 1.2

w[3][5]: 0.65
e[3][5]: 1.5

w[1][4]: 0.85
e[1][4]: 2.25

w[2][5]: 0.8
e[2][5]: 2.05

w[1][5]: 1.15
e[1][5]: 3.25

最优二叉树的根节点为: 各子树的根：
1 1 1 1 3
0 2 2 3 4
0 0 3 3 4
0 0 0 4 5
0 0 0 0 5

最优二叉树结构：
最优二叉树的结果为:
k3是根
最优二叉树的结果为:
k1是k3的左孩子
最优二叉树的结果为:
d0是k1的左孩子
最优二叉树的结果为:
k2是k1的右孩子
最优二叉树的结果为:
d1是k2的左孩子
最优二叉树的结果为:
d2是k2的右孩子
最优二叉树的结果为:
k5是k3的右孩子
最优二叉树的结果为:
k4是k5的左孩子
最优二叉树的结果为:
d3是k4的左孩子
最优二叉树的结果为:
d4是k4的右孩子
最优二叉树的结果为:
d5是k5的右孩子

请输入顺序表的长度：4
请依次输入该数组的数据：2 3 -1 5
首先声明一个d[n]数组用来存储第i个数据加到第rec[i]个数据的和,rec[n]用来记录第i个元素加到第几个元素能得到最大值

初始化d[n-1]就等于最后一个元素的值,rec[n-1]就等于n-1,因为最后一个元素不能再 往后加了

从后往前遍历：

当d[3]的值大于零时, d[2]的值就等于当前数据值加上d[3]
同时rec[2]的值就等于rec[3]的值

当d[2]的值大于零时, d[1]的值就等于当前数据值加上d[2]
同时rec[1]的值就等于rec[2]的值

当d[1]的值大于零时, d[0]的值就等于当前数据值加上d[1]
同时rec[0]的值就等于rec[1]的值

因为d[i]存储的是从第i个元素开始的最大字段和,所以要求整个序列的最大字段和,只 需要遍历d[n]得到最大值就行

最大字段和为：9
最优解为：1,4

请输入第一个序列的长度：4
请输入第二个序列的长度：3
请依次输入第一个序列的内容：2 3 1 4
请依次输入第二个序列的内容：2 3 4

首先初始化一个二维数组c[m][n]来存储第一个序列的前i个元素与第二个序列的前j个 元素之间最长公共子序列的长度

m是第一个序列的长度,n是第二个序列的长度,i代表行数,j代表列数
因为第一个 序列中的第1个元素“2”与y中的第1个元素“2”相等
所以让c[1][1]的值相对于c[0][0]的值加一

因为第一个序列中的第1个元素“2”与y中的第2个元素“3”不相等
所以让c[1][2]的值取c[0][2]和c[1][1]中更大的那个

因为第一个序列中的第1个元素“2”与y中的第3个元素“4”不相等
所以让c[1][3]的值取c[0][3]和c[1][2]中更大的那个

因为第一个序列中的第2个元素“3”与y中的第1个元素“2”不相等
所以让c[2][1]的值取c[1][1]和c[2][0]中更大的那个

因为第一个序列中的第2个元素“3”与y中的第2个元素“3”相等
所以让c[2][2]的值相对于c[1][1]的值加一

因为第一个序列中的第2个元素“3”与y中的第3个元素“4”不相等
所以让c[2][3]的值取c[1][3]和c[2][2]中更大的那个

因为第一个序列中的第3个元素“1”与y中的第1个元素“2”不相等
所以让c[3][1]的值取c[2][1]和c[3][0]中更大的那个

因为第一个序列中的第3个元素“1”与y中的第2个元素“3”不相等
所以让c[3][2]的值取c[2][2]和c[3][1]中更大的那个

因为第一个序列中的第3个元素“1”与y中的第3个元素“4”不相等
所以让c[3][3]的值取c[2][3]和c[3][2]中更大的那个

因为第一个序列中的第4个元素“4”与y中的第1个元素“2”不相等
所以让c[4][1]的值取c[3][1]和c[4][0]中更大的那个

因为第一个序列中的第4个元素“4”与y中的第2个元素“3”不相等
所以让c[4][2]的值取c[3][2]和c[4][1]中更大的那个

因为第一个序列中的第4个元素“4”与y中的第3个元素“4”相等
所以让c[4][3]的值相对于c[3][2]的值加一

c[i][j]:
       1 1 1
       1 2 2
       1 2 2
       1 2 3

因为c[4][3]代表第一个序列中的前4个元素和第二个序列中的前3个元素的最大字段和
所以长子序列长度是：3
输入一课完全二叉树
节点数：7
输入完全二叉树的值：
3 2 3 -1 3 -1 1

开始构造二叉树

寻找2,3的父节点, i: 2
目标父节点在1层
目标层的节点个数: 2
当前层: 1, 下一层的节点个数: 2
已累计的目标层节点: 2
目标父亲节点在当前节点上, 当前节点值为: 3

寻找-1,3的父节点, i: 4
目标父节点在2层
目标层的节点个数: 4
当前层: 1, 下一层的节点个数: 2
已累计的目标层节点: 4
目标父亲节点在当前节点左孩子上, 当前节点值为: 3
目标父亲节点在当前节点上, 当前节点值为: 2

寻找-1,1的父节点, i: 6
目标父节点在2层
目标层的节点个数: 4
当前层: 1, 下一层的节点个数: 2
已累计的目标层节点: 4
目标父亲节点在当前节点右孩子上, 当前节点值为: 3
目标父亲节点在当前节点上, 当前节点值为: 3

构造完成

开始偷
偷当前的获得的价值: 3
不偷当前的获得的价值: 0

偷当前的获得的价值: 2
不偷当前的获得的价值: 3

偷当前的获得的价值: 1
不偷当前的获得的价值: 0

偷当前的获得的价值: 3
不偷当前的获得的价值: 1

偷当前的获得的价值: 7
不偷当前的获得的价值: 6

最高金额为: 7
7
输入行数与列数：
3 4
输入你的矩阵：
1 2 3 4
1 2 3 4
1 2 3 4
请输入矩阵2
输入行数与列数：
3 4
输入你的矩阵：
2 1 2 1
1 2 1 2
2 2 1 1
第一个矩阵为：
1  2  3  4
1  2  3  4
1  2  3  4
第二个矩阵为：
2  1  2  1
1  2  1  2
2  2  1  1
矩阵相加运算解法如下:
第一个矩阵与第二个矩阵对应的元素值依次相加
两个矩阵的第1行对应的元素相加的结果分别为
        3       3       5       5
两个矩阵的第2行对应的元素相加的结果分别为
        2       4       4       6
两个矩阵的第3行对应的元素相加的结果分别为
        3       4       4       5

结果为：
3  3  5  5
2  4  4  6
3  4  4  5

请输入矩阵1
输入行数与列数：
2 3
输入你的矩阵：
2 3 1
3 2 1
请输入矩阵2
输入行数与列数：
2 3
输入你的矩阵：
1 2 1
1 1 1
第一个矩阵为：
2  3  1
3  2  1
第二个矩阵为：
1  2  1
1  1  1
矩阵相减运算解法如下:
第一个矩阵与第二个矩阵对应的元素值依次相减
两个矩阵的第1行对应的元素相减的结果分别为
        1       1       0
两个矩阵的第2行对应的元素相减的结果分别为
        2       1       0

结果为：
1  1  0
2  1  0

输入行数与列数：
2 3
输入你的矩阵：
2 1 2
2 3 1
请输入矩阵2
输入行数与列数：
3 2
输入你的矩阵：
1 2
2 3
3 1
第一个矩阵为：
2  1  2
2  3  1
第二个矩阵为：
1  2
2  3
3  1
矩阵相乘运算解法如下:
第一个矩阵的第1行乘第二个矩阵的每一列对应的元素，然后求和后按行排列为：
        10      9
第一个矩阵的第2行乘第二个矩阵的每一列对应的元素，然后求和后按行排列为：
        11      14
结果为：
10  9
11  14

请输入矩阵
输入行数与列数：
2 3
输入你的矩阵：
2 3 1
3 2 1
请输入数值
3
矩阵为：
2  3  1
3  2  1
数值为：
3
数乘运算解法如下:
矩阵的每个值依次乘这个数值
数据3与第1行的数相乘结果分别为
        6       9       3
数据3与第2行的数相乘结果分别为
        9       6       3
结果为：
6  9  3
9  6  3

请输入矩阵的行数: 2
请依次输入第1行的元素: 1 2
请依次输入第2行的元素: 3 2
原始矩阵:
   1         2
   3         2
1、求矩阵的逆首先我们要做的是求矩阵的行列式
顺序求和, 主对角线元素相乘之和依次是：
        2
主对角线元素相乘之和是2
逆序相减, 减去次对角线元素乘积依次是：
        6
主对角线元素相乘之和是6
因此，矩阵的行列式为：2-6=-4
去除元素A(0,0)得到的新矩阵为：
   2
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
去除元素A(0,1)得到的新矩阵为：
   3
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
去除元素A(1,0)得到的新矩阵为：
   2
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
去除元素A(1,1)得到的新矩阵为：
   1
现已经求出矩阵的行列式和矩阵的伴随矩阵。
开始根据公式A^(-1)=A*/|A|计算矩阵的逆：
矩阵的逆矩阵为:
-0.5       0.5
0.75     -0.25